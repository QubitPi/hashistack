<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.0">
<title data-rh="true">Continuous Delivery | hashicorp-aws</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://hashicorp-aws.com/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://hashicorp-aws.com/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://hashicorp-aws.com/blog/continuous-delivery"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Continuous Delivery | hashicorp-aws"><meta data-rh="true" name="description" content="[//]: # (Copyright Jiaqi Liu)"><meta data-rh="true" property="og:description" content="[//]: # (Copyright Jiaqi Liu)"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-08-31T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://continuousdelivery.com/,https://github.com/QubitPi,https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing"><meta data-rh="true" property="article:tag" content="Continuous Delivery"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://hashicorp-aws.com/blog/continuous-delivery"><link data-rh="true" rel="alternate" href="https://hashicorp-aws.com/blog/continuous-delivery" hreflang="en"><link data-rh="true" rel="alternate" href="https://hashicorp-aws.com/blog/continuous-delivery" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="hashicorp-aws RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="hashicorp-aws Atom Feed"><link rel="stylesheet" href="/assets/css/styles.bc7f6e16.css">
<script src="/assets/js/runtime~main.6dc884db.js" defer="defer"></script>
<script src="/assets/js/main.06eb71e6.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">hashicorp-aws</b></a><a class="navbar__item navbar__link" href="/docs/intro">Documentations</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/QubitPi/hashicorp-aws" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/testing-hashicorp-terraform">Testing HashiCorp Terraform</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/version-bump">Bumping Semantic Version by GitHub Tag</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/cypress-e2e">Cypress E2E Tests</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/jdk-setup">Setting up JDK in GitHub Actions</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/npm-release">NPM Release action</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/ui-unit-test">UI Unit Test</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/ui-code-style">UI Code Style</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/yml-and-md-style-checks">Performing Style Check on YAML &amp; Markdown Files and Link Check</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/github-secret-action">Reusable GitHub Action - Posting GitHub Secrets</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/github-slack-notification">Sending GitHub Action Results to Slack Channel</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/github-matrix">Using a GitHub Action Matrix to Define Variations for Each Job</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/openssl-encrypt">Using OpenSSL to encrypt messages and files on Linux</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/dockerhub-github-actions">Build and Push Docker Images through GitHub Action</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/nvm">Switching Node.js Versions with NVM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/jenkins-on-aws">Deploying Jenkins to AWS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/aws-troubleshooting">AWS Troubleshooting</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/aws-iam">AWS Identity and Access Management (IAM)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/nexus">Nexus 3 Repository Manager OSS</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/continuous-delivery">Continuous Delivery</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/deploying-vs-releasing">Deploying v.s. Releasing</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/docker-c-advisor">Docker cAdvisor</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/yahoo-object-storage">Yahoo Cloud Object Store - Object Storage at Exabyte Scale</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/ssh-ascii-banner">Add Custom ASCII Banner Logo to SSH Login Screen</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/trunk-based-deployment">Trunk-Based Development</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/aws-s3-concepts">Amazon S3 concepts</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="https://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="[//]: # (Copyright Jiaqi Liu)"><header><h1 class="title_f1Hy" itemprop="headline">Continuous Delivery</h1><div class="container_mt6G margin-vert--md"><time datetime="2022-08-31T00:00:00.000Z" itemprop="datePublished">August 31, 2022</time> · <!-- -->30 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://continuousdelivery.com/" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://continuousdelivery.com/images/cd-book.png" alt="continuousdelivery.com" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://continuousdelivery.com/" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">continuousdelivery.com</span></a></div><small class="avatar__subtitle" itemprop="description">Origin</small></div></div></div><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/QubitPi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/16126939?v=4" alt="Jiaqi Liu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/QubitPi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Jiaqi Liu</span></a></div><small class="avatar__subtitle" itemprop="description">Maintainer of hashicorp-aws</small></div></div></div><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://wac-cdn.atlassian.com/dam/jcr:57a8bbb8-4f5c-46fc-9ceb-224cf79af3d8/Screen%20Shot%202017-04-14%20at%2010.43.26%20AM.png?cdnVersion=998" alt="Sten Pittet" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Sten Pittet</span></a></div></div></div></div></div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><p>Continuous delivery is an approach where teams release quality products frequently and predictably from source code
repository to production in an automated fashion.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="what-is-continuous-delivery">What is Continuous Delivery<a href="#what-is-continuous-delivery" class="hash-link" aria-label="Direct link to What is Continuous Delivery" title="Direct link to What is Continuous Delivery">​</a></h2>
<p>Continuous Delivery is the ability to get changes of all types - including new features, configuration changes, bug
fixes and experiments - into production, or into the hands of users, <em>safely</em> and <em>quickly</em> in a <em>sustainable</em> way.</p>
<p>The goal of continuous delivery is to make deployments - whether of a large-scale distributed system, a complex
production environment, an embedded system, or an app - predictable, routine affairs that can be performed on demand.</p>
<p>We achieve all this by ensuring our code is always in a deployable state, even in the face of teams of thousands of
developers making changes on a daily basis. We thus completely eliminate the integration, testing and hardening phases
that traditionally followed &quot;dev complete&quot;, as well as code freezes.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="why-continuous-delivery">Why Continuous Delivery<a href="#why-continuous-delivery" class="hash-link" aria-label="Direct link to Why Continuous Delivery" title="Direct link to Why Continuous Delivery">​</a></h3>
<p>It is often assumed that if we want to deploy software more frequently, we must accept lower levels of stability and
reliability in our systems. In fact, peer-reviewed research shows that this is not the case. High performance teams
consistently deliver services faster and more reliably than their low performing competition. This is true even in
highly regulated domains such as <a href="https://www.youtube.com/watch?v=eMS97X5ZTGc" target="_blank" rel="noopener noreferrer">financial services</a> and
<a href="https://www.youtube.com/watch?v=QwHVlJtqhaI" target="_blank" rel="noopener noreferrer">government</a>. This capability provides an incredible competitive advantage
for organizations that are willing to invest the effort to pursue it.</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</div><div class="admonitionContent_BuS1"><ul>
<li>Firms with high-performing IT organizations were twice as likely to exceed their profitability, market share and
productivity goals.</li>
<li>High performers achieved higher levels of both throughput and stability.</li>
<li>The use of continuous delivery practices including version control, continuous integration, and test automation
predicts higher IT performance.</li>
<li>Culture is measurable and predicts job satisfaction and organizational performance.</li>
<li>Continuous Delivery measurably reduces both deployment pain and team burnout.</li>
</ul></div></div>
<p>The practices at the heart of continuous delivery help us achieve several important benefits:</p>
<ul>
<li>
<p><strong>Low risk releases</strong>. The primary goal of continuous delivery is to make software deployments painless, low-risk
events that can be performed at any time, on demand. By applying <a href="#patterns">patterns</a> such as <strong>blue-green
deployments</strong> it is relatively straightforward to achieve zero-downtime deployments that are undetectable to users.</p>
<p>:::info blue-green deployment</p>
<p><img loading="lazy" alt="Error loading blue-green-deployments.png " src="/assets/images/blue-green-deployments-5a0c344650154229cb4af876bd9f7f4a.png" width="953" height="607" class="img_ev3q"></p>
<p>One of the challenges with automating deployment is the cut-over itself, taking software from the final stage of
testing to live production. We usually need to do this quickly in order to minimize downtime. The blue-green
deployment approach does this by ensuring we have <strong>two production environments</strong>, as identical as possible. At any
time one of them, let&#x27;s say blue for the example, is live. As we prepare a new release of our software we do our
final stage of testing in the green environment. Once the software is working in the green environment, we switch the
router so that all incoming requests go to the green environment - the blue one is now idle.</p>
<p>Blue-green deployment also gives us a rapid way to rollback - if anything goes wrong we switch the router back to
our blue environment. There&#x27;s still the issue of dealing with missed transactions while the green environment was
live, but depending on our design we may be able to feed transactions to both environments in such a way as to keep
the blue environment as a backup when the green is live. Or we may be able to put the application in read-only mode
before cut-over, run it for a while in read-only mode, and then switch it to read-write mode. That may be enough to
flush out many outstanding issues.</p>
<p>The two environments need to be different but as identical as possible. In some situations they can be different
pieces of hardware, or they can be different virtual machines running on the same (or different) hardware. They can
also be a single operating environment partitioned into separate zones with separate IP addresses for the two slices.</p>
<p>Once we&#x27;ve put our green environment live and we&#x27;re happy with its stability, we then use the blue environment as
our <strong>staging environment</strong> for the final testing step for our next deployment. When we are ready for our next
release, we switch from green to blue in the same way that we did from blue to green earlier. That way both green and
blue environments are regularly cycling between live, previous version (for rollback) and staging the next version.</p>
<p>An advantage of this approach is that it&#x27;s the same basic mechanism as we need to get a hot-standby working. Hence
this allows us to test our disaster-recovery procedure on every release.</p>
<p>The fundamental idea is to have two easily switchable environments to switch between, there are plenty of ways to vary
the details. One project did the switch by bouncing the web server rather than working on the router. Another
variation would be to use the same database, making the blue-green switches for web and domain layers.</p>
<p>Databases can often be a challenge with this technique, particularly when we need to change the schema to support a
new version of the software. The trick is to <strong>separate the deployment of schema changes from application upgrades</strong>.
So first apply a database refactoring to change the schema to support both the new and old version of the application,
deploy that, check everything is working fine so we have a rollback point, then deploy the new version of the
application. (And when the upgrade has bedded down remove the database support for the old version.)
:::</p>
</li>
<li>
<p><strong>Faster time to market</strong>. It&#x27;s common for the integration and test/fix phase of the traditional phased software
delivery lifecycle to consume weeks to even months. When teams work together to automate the build and deployment,
environment provisioning, and regression testing process, developers can incorporate integration and regression
testing into their daily work and completely remove these phases. We also avoid the large amount of re-work that
plague the phased approach.</p>
</li>
<li>
<p><strong>Higher quality and Better products</strong>. When developers have automated tools that discover regressions within minutes,
teams are freed to <strong>focus their effort on user research and higher level testing activities</strong> such as exploratory
testing, usability testing, and performance and security testing. By building a deployment pipeline, these activities
can be performed continuously throughout the delivery process, ensuring quality is built into products and services
from the beginning. Continuous delivery makes it economic to work in small batches. This means we can get feedback
from users throughout the delivery lifecycle based on working software.</p>
</li>
<li>
<p><strong>Lower costs</strong>. Any successful software product or service will evolve significantly over the course of its lifetime.
By investing in build, test, deployment and environment automation, we substantially reduce the cost of making and
delivering incremental changes to software by <strong>eliminating many of the fixed costs</strong> associated with the release
process.</p>
</li>
<li>
<p><strong>Happier teams</strong>. Continuous Delivery makes releases less painful and reduces team burnout. Furthermore, when we
release more frequently, software delivery teams can engage more actively with users, learn which ideas work and which
don&#x27;t, and see first-hand then outcomes of the work they have done. By removing low-value painful activities
accociated with software delivery, we can fodus on what we care about most - continuous delighting our users.</p>
</li>
</ul>
<p><strong>Continuous delivery is about continuous, daily improvement - the constant discipline of pursuing higher performance by
following the heuristic &quot;if it hurts, do it more often, and bring the pain forward.&quot;</strong></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="principles">Principles<a href="#principles" class="hash-link" aria-label="Direct link to Principles" title="Direct link to Principles">​</a></h2>
<p>There are five principles at the heart of continuous delivery:</p>
<ol>
<li>Build quality in</li>
<li>Work in small batches</li>
<li>Computers perform repetitive tasks, people solve problems</li>
<li>Relentlessly pursue continuous improvement</li>
<li>Everyone is responsible</li>
</ol>
<p>It&#x27;s easy to get bogged down in the details of implementing continuous delivery - tools, architecture, practices,
politics - if you find yourself lost, try revisiting these principles and you may find it helps you refocus on what&#x27;s
important.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="build-quality-in">Build Quality In<a href="#build-quality-in" class="hash-link" aria-label="Direct link to Build Quality In" title="Direct link to Build Quality In">​</a></h3>
<p>W. Edwards Deming, a key figure in the history of the Lean movement, offered
<a href="https://deming.org/explore/fourteen-points" target="_blank" rel="noopener noreferrer">14 key principles</a> for management. Principle three states, &quot;Cease
dependence on inspection to achieve quality. Eliminate the need for inspection on a mass basis by building quality into
the product in the first place&quot;.</p>
<p>It&#x27;s much cheaper to fix problems and defects if we find them immediately - ideally before they are ever checked into
version control, by running automated tests locally. Finding defects downstream through inspection (such as manual
testing) is time-consuming, requiring significant triage. Then we must fix the defect, trying to recall what we were
thinking when we introduced the problem days or perhaps even weeks ago.</p>
<p>Creating and evolving feedback loops to detect problems as early as possible is essential and never-ending work in
continuous delivery. If we find a problem in our exploratory testing, we must not only fix it, but then ask: How could
we have caught the problem with an automated acceptance test? When an acceptance test fails, we should ask: Could we
have written a unit test to catch this problem?</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="work-in-small-batches">Work in Small Batches<a href="#work-in-small-batches" class="hash-link" aria-label="Direct link to Work in Small Batches" title="Direct link to Work in Small Batches">​</a></h3>
<p>In traditional phased approaches to software development, handoffs from dev to test or test to IT operations consist of
whole releases: months worth of work by teams consisting of tens or hundreds of people.</p>
<p>In continuous delivery, we take the opposite approach, and try and get every change in version control as far towards
release as we can, getting comprehensive feedback as rapidly as possible.</p>
<p>Working in small batches has many benefits. It reduces the time it takes to get feedback on our work, makes it easier to
triage and remediate problems, increases efficiency and motivation, and prevents us from succumbing to the sunk cost
fallacy.</p>
<p>The reason we work in large batches is because of the large fixed cost of handing off changes. <strong>A key goal of
continuous delivery is to change the economics of the software delivery process to make it economically viable to work
in small batches so we can obtain the many benefits of this approach</strong>.</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</div><div class="admonitionContent_BuS1"><p>A key goal of continuous delivery is to change the economics of the software delivery process to make it economically
viable to work in small batches so we can obtain the many benefits of this approach</p></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="relentlessly-pursue-continuous-improvement">Relentlessly Pursue Continuous Improvement<a href="#relentlessly-pursue-continuous-improvement" class="hash-link" aria-label="Direct link to Relentlessly Pursue Continuous Improvement" title="Direct link to Relentlessly Pursue Continuous Improvement">​</a></h3>
<p>Continuous improvement, or <em>kaizen</em> in Japanese, is another key idea from the Lean movement.
<a href="http://www.amazon.com/dp/0071808019?tag=contindelive-20" target="_blank" rel="noopener noreferrer">Taiichi Ohno</a>, a key figure in the history of the Toyota
company, once said,</p>
<blockquote>
<p>&quot;Kaizen opportunitites are infinite. Don&#x27;t think you have made things better than before and be at ease… This would be
like the student who becomes proud because they bested their master two times out of three in fencing. Once you pick
up the sprouts of kaizen ideas, it is important to have the attitude in our daily work that just underneath one kaizen
idea is yet another one&quot;.</p>
</blockquote>
<p>Don&#x27;t treat transformation as a project to be embarked on and then completed so we can return to business as usual. The
best organizations are those where everybody treats improvement work as an essential part of their daily work, and where
nobody is satisfied with the status quo.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="everyone-is-responsible">Everyone is Responsible<a href="#everyone-is-responsible" class="hash-link" aria-label="Direct link to Everyone is Responsible" title="Direct link to Everyone is Responsible">​</a></h3>
<p>In high performing organizations, nothing is &quot;somebody else&#x27;s problem.&quot; Developers are responsible for the quality and
stability of the software they build. Operations teams are responsible for helping developers build quality in. Everyone
works together to achieve the organizational level goals, rather than optimizing for what’s best for their team or
department.</p>
<p>When people make local optimizations that reduce the overall performance of the organization, it&#x27;s often due to systemic
problems such as poor management systems such as annual budgeting cycles, or incentives that reward the wrong behaviors.
A classic example is rewarding developers for increasing their velocity or writing more code, and rewarding testers
based on the number of bugs they find.</p>
<p>Most people want to do the right thing, but they will adapt their behaviour based on how they are rewarded. Therefore,
it is very important to create fast feedback loops from the things that really matter: how customers react to what we
build for them, and the impact on our organization.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="foundations---prerequisites-for-continuous-delivery">Foundations - Prerequisites for Continuous Delivery<a href="#foundations---prerequisites-for-continuous-delivery" class="hash-link" aria-label="Direct link to Foundations - Prerequisites for Continuous Delivery" title="Direct link to Foundations - Prerequisites for Continuous Delivery">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="configuration-management">Configuration Management<a href="#configuration-management" class="hash-link" aria-label="Direct link to Configuration Management" title="Direct link to Configuration Management">​</a></h3>
<p>Automation plays a vital role in ensuring we can release software repeatably and reliably. One key goal is to take
repetitive manual processes like build, deployment, regression testing and infrastructure provisioning, and automate
them. In order to achieve this, we need to version control everything required to perform these processes, including
source code, test and deployment scripts, infrastructure and application configuration information, and the many
libraries and packages we depend upon. We also want to make it straightforward to query the current -and historical -
state of our environments.</p>
<p>We have two overriding goals:</p>
<ol>
<li><strong>Reproducibility</strong>: We should be able to provision any environment in a fully automated fashion, and know that any
new environment reproduced from the same configuration is identical.</li>
<li><strong>Traceability</strong>: We should be able to pick any environment and be able to determine quickly and precisely the
versions of every dependency used to create that environment. We also want to be able to compare previous versions of
an environment and see what has changed between them.</li>
</ol>
<p>These capabilities give us several very important benefits:</p>
<ol>
<li><strong>Disaster recovery</strong>: When something goes wrong with one of our environments, for example a hardware failure or a
security breach, we need to be able to reproduce that environment in a deterministic amount of time in order to be
able to restore service.</li>
<li><strong>Auditability</strong>: In order to demonstrate the integrity of the delivery process, we need to be able to show the path
backwards from every deployment to the elements it came from, including their version. Comprehensive configuration
management, combined with deployment pipelines, enable this.</li>
<li><strong>Higher quality</strong>: The software delivery process is often subject to long delays waiting for development, testing
and production environments to be prepared. When this can be done automatically from version control, we can get
feedback on the impact of our changes much more rapidly, enabling us to build quality in to our software.</li>
<li><strong>Capacity management</strong>: When we want to add more capacity to our environments, the ability to create new
reproductions of existing servers is essential. This capability, using <a href="https://www.openstack.org/" target="_blank" rel="noopener noreferrer">OpenStack</a> for
example, enables the horizontal scaling of modern cloud-based distributed systems.</li>
<li><strong>Response to defects</strong>: When we discover a critical defect, or a vulnerability in some component of our system, we
want to get a new version of our software released as quickly as possible. Many organizations have an emergency
process for this type of change which goes faster by bypassing some of the testing and auditing. This presents an
especially serious dilemma in safety-critical systems. Our goal should be to be able to use our normal release
process for emergency fixes - which is precisely what continuous delivery enables, on the basis of comprehensive
configuration management.</li>
</ol>
<p>As environments become more complex and heterogeneous, it becomes progressively harder to achieve these goals. Achieving
perfect reproducibility and traceability to the last byte for a complex enterprise system is impossible (apart from
anything else, every real system has state). Thus a key part of configuration management is working to <strong>simplify our
architecture, environments and processes</strong> to reduce the investment required to achieve the desired benefits.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="configuration-management-learning-resources">Configuration Management Learning Resources<a href="#configuration-management-learning-resources" class="hash-link" aria-label="Direct link to Configuration Management Learning Resources" title="Direct link to Configuration Management Learning Resources">​</a></h4>
<ul>
<li><a href="https://www.oreilly.com/library/view/infrastructure-as-code/9781491924334/" target="_blank" rel="noopener noreferrer">Infrastructure as Code</a></li>
<li><a href="http://www.infoq.com/presentations/scaling-operations-facebook" target="_blank" rel="noopener noreferrer">Pedro Canahuati on scaling operations at Facebook</a></li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="continuous-integration">Continuous Integration<a href="#continuous-integration" class="hash-link" aria-label="Direct link to Continuous Integration" title="Direct link to Continuous Integration">​</a></h3>
<p>Combining the work of multiple developers is hard. Software systems are complex, and an apparently simple,
self-contained change to a single file can easily have unintended consequences which compromise the correctness of the
system. As a result, some teams have developers work isolated from each other on their own branches, both to keep
trunk/master stable, and to prevent them treading on each other’s toes.</p>
<p>However, over time these branches diverge from each other. While merging a single one of these branches into mainline is
not usually troublesome, the work required to integrate multiple long-lived branches into mainline is usually painful,
requiring significant amounts of re-work as conflicting assumptions of developers are revealed and must be resolved.</p>
<p>Teams using long-lived branches often require code freezes, or even integration and stabilization phases, as they work
to integrate these branches prior to a release. Despite modern tooling, this process is still expensive and
unpredictable. On teams larger than a few developers, the integration of multiple branches requires multiple rounds of
regression testing and bug fixing to validate that the system will work as expected following these merges. This problem
becomes exponentially more severe as team sizes grow, and as branches become more long-lived.</p>
<p>The practice of continuous integration was invented to address these problems. CI (continuous integration) follows the
XP (extreme programming) principle that if something is painful, we should do it more often, and bring the pain forward.
Thus in CI developers integrate all their work into trunk (also known as mainline or master) on a regular basis (at
least daily). A set of automated tests is run both <strong>before and after</strong> the merge to validate that no regressions are
introduced. If these automated tests fail, the team stops what they are doing and someone fixes the problem immediately.</p>
<p>Thus we ensure that the software is always in a working state, and that developer branches do not diverge significantly
from trunk. The benefits of continuous integration are very significant - higher levels of throughput, more stable
systems, and higher quality software. However the practice is still controversial, for two main reasons.</p>
<p>First, it requires developers to break up large features and other changes into smaller, more incremental steps that can
be integrated into trunk/master. This is a paradigm shift for developers who are not used to working in this way. It also
takes longer to get large features completed. However in general we don&#x27;t want to optimize for the speed at which
developers can declare their work &quot;dev complete&quot; on a branch. Rather, we want to be able to get changes reviewed,
integrated, tested and deployed as fast as possible - and this process is an order of magnitude faster and cheaper when
the changes are small and self-contained, and the branches they live on are short-lived. Working in small batches also
ensures developers get regular feedback on the impact of their work on the system as a whole - from other developers,
testers, customers, and automated performance and security tests—which in turn makes any problems easier to detect,
triage, and fix.</p>
<p>Second, continuous integration requires a fast-running set of comprehensive automated unit tests. These tests should be
comprehensive enough to give a good level of confidence that the software will work as expected, while also running in a
few minutes or less. If the automated unit tests take longer to run, developers will not want to run them frequently,
and they will become harder to maintain. Creating maintainable suites of automated unit tests is complex and is best done
through test-driven development (TDD), in which developers write failing automated tests before they implement the code
that makes the tests pass. TDD has several benefits, the most important of which is that it ensures developers write code
that is modular and easy to test, reducing the maintenance cost of the resulting automated test suites. But TDD is still
not sufficiently widely practiced.</p>
<p>Despite these barriers, <strong>helping software development teams implement continuous integration should be the number one
priority for any organization</strong> wanting to start the journey to continuous delivery. By creating rapid feedback loops
and ensuring developers work in small batches, CI enables teams to build quality into their software, thus reducing the
cost of ongoing software development, and increasing both the productivity of teams and the quality of the work they
produce.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="continuous-integration-learning-resources">Continuous Integration Learning Resources<a href="#continuous-integration-learning-resources" class="hash-link" aria-label="Direct link to Continuous Integration Learning Resources" title="Direct link to Continuous Integration Learning Resources">​</a></h4>
<ul>
<li><a href="http://www.amazon.com/dp/0321336380?tag=contindelive-20" target="_blank" rel="noopener noreferrer">Paul Duvall&#x27;s book on Continuous Integration</a></li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="continuous-testing">Continuous Testing<a href="#continuous-testing" class="hash-link" aria-label="Direct link to Continuous Testing" title="Direct link to Continuous Testing">​</a></h3>
<p>The key to building quality into our software is making sure we can get fast feedback on the impact of changes.
Traditionally, extensive use was made of manual inspection of code changes and manual testing (testers following
documentation describing the steps required to test the various functions of the system) in order to demonstrate the
correctness of the system. This type of testing was normally done in a phase following “dev complete”. However this
strategy have several drawbacks:</p>
<ul>
<li>Manual regression testing takes a long time and is relatively expensive to perform, creating a bottleneck that
prevents us releasing software more frequently, and getting feedback to developers weeks (and sometimes months) after
they wrote the code being tested.</li>
<li>Manual tests and inspections are not very reliable, since people are notoriously poor at performing repetitive tasks
such as regression testing manually, and it is extremely hard to predict the impact of a set of changes on a complex
software system through inspection.</li>
<li>When systems are evolving over time, as is the case in modern software products and services, we have to spend
considerable effort updating test documentation to keep it up-to-date.</li>
</ul>
<p>In order to build quality in to software, we need to adopt a
<a href="#different-types-of-software-testing">different approach</a>.</p>
<p>The more features and improvements go into our code, the more we&#x27;ll need to test to make sure that all our system works
properly. And then for each bug we fix, it would be wise to check that they don&#x27;t get back in newer releases.
Automation is key to make this possible and writing tests sooner rather than later will become part of our development
workflow.</p>
<p>Once we have continuous integration and test automation in place, we create a
<a href="#the-deployment-pipeline">deployment pipeline</a>. In the deployment pipeline pattern, every change runs a build that</p>
<ul>
<li>creates packages that can be deployed to any environment and</li>
<li>runs unit tests (and possibly other tasks such as static analysis), giving feedback to developers in the space of a
few minutes.</li>
</ul>
<p>Packages that pass this set of tests have more comprehensive automated acceptance tests run against them. Once we have
packages that pass all the automated tests, they are available for deplyment to other environments.</p>
<p>In the deployment pipeline, every change is effectively a release candidate. The job of the deployment pipeline is to
catch known issues. If we can&#x27;t detect any known problems, we should feel totally comfortable releasing any packages
that have gone through it. If we aren&#x27;t, or if we discover defects later, it means we need to improve our pipeline,
perhaps adding or updating some tests.</p>
<p>Our goal should be to find problems as soon as possible, and make the lead time from check-in to release as short as
possible. Thus we want to parallelize the activities in the deployment pipeline, not have many stages executing in
series. If we discover a defect in the acceptance tests, we should be looking to improve our unit tests (most of our
defects should be discovered through unit testing).</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="different-types-of-software-testing">Different Types of Software Testing<a href="#different-types-of-software-testing" class="hash-link" aria-label="Direct link to Different Types of Software Testing" title="Direct link to Different Types of Software Testing">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="unit-tests">Unit Tests<a href="#unit-tests" class="hash-link" aria-label="Direct link to Unit Tests" title="Direct link to Unit Tests">​</a></h5>
<p>Unit tests are very low level and close to the source of an application. They consist in testing individual methods and
functions of the classes, components, or modules used by our software. Unit tests are generally quite cheap to automate
and can run very quickly by a continuous integration server.</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="integration-tests">Integration Tests<a href="#integration-tests" class="hash-link" aria-label="Direct link to Integration Tests" title="Direct link to Integration Tests">​</a></h5>
<p>Integration tests verify that different modules or services used by our application work well together. For example, it
can be testing the interaction with the database or making sure that microservices work together as expected. These
types of tests are more expensive to run as they require multiple parts of the application to be up and running.</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="functional-tests">Functional Tests<a href="#functional-tests" class="hash-link" aria-label="Direct link to Functional Tests" title="Direct link to Functional Tests">​</a></h5>
<p>Functional tests focus on the business requirements of an application. They only verify the output of an action and do
not check the intermediate states of the system when performing that action.</p>
<p>There is sometimes a confusion between integration tests and functional tests as they both require multiple components
to interact with each other. The difference is that an integration test may simply verify that we can query the
database while a functional test would expect to get a specific value from the database as defined by the product
requirements.</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="end-to-end-tests">End-to-End Tests<a href="#end-to-end-tests" class="hash-link" aria-label="Direct link to End-to-End Tests" title="Direct link to End-to-End Tests">​</a></h5>
<p>End-to-end testing replicates a user behavior with the software in a complete application environment. It verifies that
various user flows work as expected and can be as simple as loading a web page or logging in or much more complex
scenarios verifying email notifications, online payments, etc...</p>
<p>End-to-end tests are very useful, but they&#x27;re expensive to perform and can be hard to maintain when they&#x27;re automated.
It is recommended to have a few key end-to-end tests and rely more on lower level types of testing (unit and
integration tests) to be able to quickly identify breaking changes.</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="acceptance-tests">Acceptance Tests<a href="#acceptance-tests" class="hash-link" aria-label="Direct link to Acceptance Tests" title="Direct link to Acceptance Tests">​</a></h5>
<p>Acceptance tests are formal tests that verify if a system satisfies business requirements. They require the entire
application to be running while testing and focus on replicating user behaviors. But they can also go further and
measure the performance of the system and reject changes if certain goals are not met.</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="performance-tests">Performance Tests<a href="#performance-tests" class="hash-link" aria-label="Direct link to Performance Tests" title="Direct link to Performance Tests">​</a></h5>
<p>Performance tests evaluate how a system performs under a particular workload. These tests help to measure the
reliability, speed, scalability, and responsiveness of an application. For instance, a performance test can observe
response times when executing a high number of requests, or determine how a system behaves with a significant amount of
data. It can determine if an application meets performance requirements, locate bottlenecks, measure stability during
peak traffic, and more.</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="smoke-tests">Smoke Tests<a href="#smoke-tests" class="hash-link" aria-label="Direct link to Smoke Tests" title="Direct link to Smoke Tests">​</a></h5>
<p>Smoke tests are basic tests that check the basic functionality of an application. They are meant to be quick to
execute, and their goal is to give us the assurance that the major features of our system are working as expected.</p>
<p>Smoke tests can be useful right after a new build is made to decide whether or not we can run more expensive tests, or
right after a deployment to make sure that they application is running properly in the newly deployed environment.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="implementing-continuous-delivery">Implementing Continuous Delivery<a href="#implementing-continuous-delivery" class="hash-link" aria-label="Direct link to Implementing Continuous Delivery" title="Direct link to Implementing Continuous Delivery">​</a></h2>
<p>Organizations attempting to deploy continuous delivery tend to make two common mistakes. The first is to treat
continuous delivery as an end-state, a goal in itself. The second is to spend a lot of time and energy worrying about
what products to use.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="evolutionary-architecture">Evolutionary Architecture<a href="#evolutionary-architecture" class="hash-link" aria-label="Direct link to Evolutionary Architecture" title="Direct link to Evolutionary Architecture">​</a></h3>
<p>In the context of enterprise architecture there are typically multiple attributes we are concerned about, for example
availability, security, performance, usability and so forth. In continuous delivery, we introduce two new architectural
attributes:</p>
<ol>
<li><strong>testability</strong></li>
<li><strong>deployability</strong></li>
</ol>
<p>In a <em>testable</em> architecture, we design our software such that most defects can (in principle, at least) be discovered
by developers by running automated tests on their workstations. We shouldn’t need to depend on complex, integrated
environments in order to do the majority of our acceptance and regression testing.</p>
<p>In a <em>deployable</em> architecture, deployments of a particular product or service can be performed independently and in a
fully automated fashion, without the need for significant levels of orchestration. Deployable systems can typically be
upgraded or reconfigured with zero or minimal downtime.</p>
<p>Where testability and deployability are not prioritized, we find that much testing requires the use of complex,
integrated environments, and deployments are &quot;big bang&quot; events that require that many services are released at the same
time due to complex interdependencies. These &quot;big bang&quot; deployments require many teams to work together in a carefully
orchestrated fashion with many hand-offs, and dependencies between hundreds or thousands of tasks. Such deployments
typically take many hours or even days, and require scheduling significant downtime.</p>
<p>Designing for testability and deployability starts with ensuring our products and services are composed of
loosely-coupled, well-encapsulated components or modules</p>
<p>We can define a well-designed modular architecture as one in which it is possible to test or deploy a single component
or service on its own, with any dependencies replaced by a suitable test double, which could be in the form of a virtual
machine, a stub, or a mock. Each component or service should be deployable in a fully automated fashion on developer
workstations, test environments, or in production. In a well-designed architecture, it is possible to get a high level of
confidence the component is operating properly when deployed in this fashion.</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Test Double</div><div class="admonitionContent_BuS1"><p>Test Double is a generic term for any case where you replace a production object for testing purposes. There are various
kinds of double:</p><ul>
<li><strong>Dummy</strong> objects are passed around but never actually used. Usually they are just used to fill parameter lists.</li>
<li><strong>Fake</strong> objects actually have working implementations, but usually take some shortcut which makes them not suitable
for production (an InMemoryTestDatabase is a good example).</li>
<li><strong>Stubs</strong> provide canned answers to calls made during the test, usually not responding at all to anything outside
what&#x27;s programmed in for the test.</li>
<li><strong>Spies</strong> are stubs that also record some information based on how they were called. One form of this might be an email
service that records how many messages it was sent.</li>
<li><strong>Mocks</strong> are pre-programmed with expectations which form a specification of the calls they are expected to receive.
They can throw an exception if they receive a call they don&#x27;t expect and are checked during verification to ensure
they got all the calls they were expecting.</li>
</ul></div></div>
<p>Any true service-oriented architecture should have these properties—but unfortunately many do not. However, the
microservices movement has explicitly prioritized these architectural properties.</p>
<p>Of course, many organizations are living in a world where services are distinctly hard to test and deploy. Rather than
re-architecting everything, we recommend an iterative approach to improving the design of enterprise system, sometimes
known as evolutionary architecture. In the evolutionary architecture paradigm, we accept that successful products and
services will require re-architecting during their lifecycle due to the changing requirements placed on them.</p>
<p>One pattern that is particularly valuable in this context is the strangler application. In this pattern, we iteratively
replace a monolithic architecture with a more componentized one by ensuring that new work is done following the
principles of a service-oriented architecture, while accepting that the new architecture may well delegate to the system
it is replacing. Over time, more and more functionality will be performed in the new architecture, and the old system
being replaced is &quot;strangled&quot;.</p>
<p><img loading="lazy" src="/assets/images/strangler-a317ed534afb581ac45d77ac9a89616a.png" width="1458" height="748" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="patterns">Patterns<a href="#patterns" class="hash-link" aria-label="Direct link to Patterns" title="Direct link to Patterns">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="the-deployment-pipeline">The Deployment Pipeline<a href="#the-deployment-pipeline" class="hash-link" aria-label="Direct link to The Deployment Pipeline" title="Direct link to The Deployment Pipeline">​</a></h4>
<p>The key pattern introduced in continuous delivery is the <strong>deployment pipeline</strong>. Our goal was to make deployment to any
environment a fully automated, scripted process that could be performed on demand in minutes. We wanted to be able to
configure testing and production environments purely from configuration files stored in version control. The apparatus
we used to perform these tasks became known as <em>deployment pipelines</em></p>
<p>In the deployment pipeline pattern, every change in version control triggers a process (usually in a CI server) which
creates deployable packages and runs automated unit tests and other validations such as static code analysis. This first
step is optimized so that it takes only a few minutes to run. If this initial commit stage fails, the problem must be
fixed immediately; nobody should check in more work on a broken commit stage. Every passing commit stage triggers the
next step in the pipeline, which might consist of a more comprehensive set of automated tests. Versions of the software
that pass all the automated tests can then be deployed to production.</p>
<p>Deployment pipelines tie together <a href="#configuration-management">configuration management</a>,
<a href="#continuous-integration">continuous integration</a> and <a href="#continuous-testing">test</a> and deployment automation in a
holistic, powerful way that works to improve software quality, increase stability, and reduce the time and cost required
to make incremental changes to software, whatever domain we&#x27;re operating in. When building a deployment pipeline, the
following practices become valuable:</p>
<ul>
<li><strong>Only build packages once</strong>. We want to be sure the thing we&#x27;re deploying is the same thing we&#x27;ve tested throughout
the deployment pipeline, so if a deployment fails we can eliminate the packages as the source of the failure.</li>
<li><strong>Deploy the same way to every environment, including development</strong>. This way, we test the deployment process many,
many times before it gets to production, and again, we can eliminate it as the source of any problems.</li>
<li><strong>Smoke test your deployments</strong>. Have a script that validates all your application&#x27;s dependencies are available, at
the location you have configured your application. Make sure your application is running and available as part of the
deployment process.</li>
<li><strong>Keep your environments similar</strong>. Although they may differ in hardware configuration, they should have the same
version of the operating system and middleware packages, and they should be configured in the same way. This has
become much easier to achieve with modern virtualization and container technology.</li>
</ul>
<p>With the advent of infrastructure as code, it has became possible to use deployment pipelines to create a fully
automated process for taking all kinds of changes—including database and infrastructure changes</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="patterns-for-low-risk-releases">Patterns for Low-Risk Releases<a href="#patterns-for-low-risk-releases" class="hash-link" aria-label="Direct link to Patterns for Low-Risk Releases" title="Direct link to Patterns for Low-Risk Releases">​</a></h3>
<p>In the context of web-based systems there are a number of patterns that can be applied to further reduce the risk of
deployments. Michael Nygard also describes a number of important software design patterns which are instrumental in
creating resilient large-scale systems in his book
<a href="http://www.amazon.com/dp/0978739213?tag=contindelive-20" target="_blank" rel="noopener noreferrer">Release It!</a></p>
<p>The 3 key principles that enable low-risk releases are</p>
<ol>
<li><strong>Optimize for Resilience</strong>. Once we accept that failures are inevitable, we should start to move away from the idea
of investing all our effort in preventing problems, and think instead about how to restore service as rapidly as
possible when something goes wrong. Furthermore, when an accident occurs, we should treat it as a learning
opportunity. Resilience isn&#x27;t just a feature of our systems, it&#x27;s a characteristic of a team&#x27;s culture. High
performance organizations are constantly working to improve the resilience of their systems by trying to break them
and implementing the lessons learned in the course of doing so.</li>
<li><strong>Low-risk Releases are Incremental</strong>. Our goal is to architect our systems such that we can release individual
changes (including database changes) independently, rather than having to orchestrate big-bang releases due to tight
coupling between multiple different systems.</li>
<li><strong>Focus on Reducing Batch Size</strong>. Counterintuitively, deploying to production more frequently actually reduces the
risk of release when done properly, simply because the amount of change in each deployment is smaller. When each
deployment consists of tens of lines of code or a few configuration settings, it becomes much easier to perform root
cause analysis and restore service in the case of an incident. Furthermore, because we practice the deployment
process so frequently, we’re forced to simplify and automate it which further reduces risk.</li>
</ol></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/continuous-delivery">Continuous Delivery</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/QubitPi/hashicorp-aws/tree/master/docs/blog/2022-08-31-continuous-delivery/index.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/nexus"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">Nexus 3 Repository Manager OSS</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/deploying-vs-releasing"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Deploying v.s. Releasing</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#what-is-continuous-delivery" class="table-of-contents__link toc-highlight">What is Continuous Delivery</a><ul><li><a href="#why-continuous-delivery" class="table-of-contents__link toc-highlight">Why Continuous Delivery</a></li></ul></li><li><a href="#principles" class="table-of-contents__link toc-highlight">Principles</a><ul><li><a href="#build-quality-in" class="table-of-contents__link toc-highlight">Build Quality In</a></li><li><a href="#work-in-small-batches" class="table-of-contents__link toc-highlight">Work in Small Batches</a></li><li><a href="#relentlessly-pursue-continuous-improvement" class="table-of-contents__link toc-highlight">Relentlessly Pursue Continuous Improvement</a></li><li><a href="#everyone-is-responsible" class="table-of-contents__link toc-highlight">Everyone is Responsible</a></li></ul></li><li><a href="#foundations---prerequisites-for-continuous-delivery" class="table-of-contents__link toc-highlight">Foundations - Prerequisites for Continuous Delivery</a><ul><li><a href="#configuration-management" class="table-of-contents__link toc-highlight">Configuration Management</a></li><li><a href="#continuous-integration" class="table-of-contents__link toc-highlight">Continuous Integration</a></li><li><a href="#continuous-testing" class="table-of-contents__link toc-highlight">Continuous Testing</a></li></ul></li><li><a href="#implementing-continuous-delivery" class="table-of-contents__link toc-highlight">Implementing Continuous Delivery</a><ul><li><a href="#evolutionary-architecture" class="table-of-contents__link toc-highlight">Evolutionary Architecture</a></li><li><a href="#patterns" class="table-of-contents__link toc-highlight">Patterns</a></li><li><a href="#patterns-for-low-risk-releases" class="table-of-contents__link toc-highlight">Patterns for Low-Risk Releases</a></li></ul></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Documentations</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/hashicorp-aws" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/QubitPi/hashicorp-aws" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 Jiaqi Liu. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>